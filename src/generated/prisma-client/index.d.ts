// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  influence: (where?: InfluenceWhereInput) => Promise<boolean>;
  keyWord: (where?: KeyWordWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  influence: (where: InfluenceWhereUniqueInput) => InfluenceNullablePromise;
  influences: (args?: {
    where?: InfluenceWhereInput;
    orderBy?: InfluenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Influence>;
  influencesConnection: (args?: {
    where?: InfluenceWhereInput;
    orderBy?: InfluenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InfluenceConnectionPromise;
  keyWord: (where: KeyWordWhereUniqueInput) => KeyWordNullablePromise;
  keyWords: (args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<KeyWord>;
  keyWordsConnection: (args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => KeyWordConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createInfluence: (data: InfluenceCreateInput) => InfluencePromise;
  updateInfluence: (args: {
    data: InfluenceUpdateInput;
    where: InfluenceWhereUniqueInput;
  }) => InfluencePromise;
  updateManyInfluences: (args: {
    data: InfluenceUpdateManyMutationInput;
    where?: InfluenceWhereInput;
  }) => BatchPayloadPromise;
  upsertInfluence: (args: {
    where: InfluenceWhereUniqueInput;
    create: InfluenceCreateInput;
    update: InfluenceUpdateInput;
  }) => InfluencePromise;
  deleteInfluence: (where: InfluenceWhereUniqueInput) => InfluencePromise;
  deleteManyInfluences: (where?: InfluenceWhereInput) => BatchPayloadPromise;
  createKeyWord: (data: KeyWordCreateInput) => KeyWordPromise;
  updateKeyWord: (args: {
    data: KeyWordUpdateInput;
    where: KeyWordWhereUniqueInput;
  }) => KeyWordPromise;
  updateManyKeyWords: (args: {
    data: KeyWordUpdateManyMutationInput;
    where?: KeyWordWhereInput;
  }) => BatchPayloadPromise;
  upsertKeyWord: (args: {
    where: KeyWordWhereUniqueInput;
    create: KeyWordCreateInput;
    update: KeyWordUpdateInput;
  }) => KeyWordPromise;
  deleteKeyWord: (where: KeyWordWhereUniqueInput) => KeyWordPromise;
  deleteManyKeyWords: (where?: KeyWordWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  influence: (
    where?: InfluenceSubscriptionWhereInput
  ) => InfluenceSubscriptionPayloadSubscription;
  keyWord: (
    where?: KeyWordSubscriptionWhereInput
  ) => KeyWordSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TimeKind = "PAST" | "FUTRUE";

export type KeyWordOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type SrcKind = "INNER" | "OUTER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "symbol_ASC"
  | "symbol_DESC"
  | "name_ASC"
  | "name_DESC"
  | "area_ASC"
  | "area_DESC"
  | "industry_ASC"
  | "industry_DESC"
  | "fullname_ASC"
  | "fullname_DESC"
  | "enname_ASC"
  | "enname_DESC"
  | "market_ASC"
  | "market_DESC"
  | "exchange_ASC"
  | "exchange_DESC"
  | "currType_ASC"
  | "currType_DESC"
  | "listStatus_ASC"
  | "listStatus_DESC"
  | "listDate_ASC"
  | "listDate_DESC"
  | "delistDate_ASC"
  | "delistDate_DESC"
  | "isHS_ASC"
  | "isHS_DESC"
  | "scope_ASC"
  | "scope_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type InfluenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "name_ASC"
  | "name_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "dierction_ASC"
  | "dierction_DESC";

export type Direction = "GOOD" | "BAD";

export type Role = "ADMIN" | "CUSTOMER";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type FactorKind =
  | "ASSET"
  | "DEBT"
  | "EQUITY"
  | "INCOME"
  | "COST"
  | "FEE"
  | "BRAND";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "src_ASC"
  | "src_DESC"
  | "srcKind_ASC"
  | "srcKind_DESC"
  | "reportTime_ASC"
  | "reportTime_DESC"
  | "happen_ASC"
  | "happen_DESC"
  | "happenTime_ASC"
  | "happenTime_DESC"
  | "content_ASC"
  | "content_DESC";

export interface KeyWordUpdateWithWhereUniqueNestedInput {
  where: KeyWordWhereUniqueInput;
  data: KeyWordUpdateDataInput;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  symbol?: Maybe<String>;
}>;

export interface KeyWordCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface CompanyUpdateWithoutPurchasesDataInput {
  symbol?: Maybe<String>;
  name?: Maybe<String>;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  influences?: Maybe<InfluenceUpdateManyWithoutCompanyInput>;
  selles?: Maybe<ProductUpdateManyWithoutOutputsInput>;
}

export interface ProductCreateManyWithoutInputsInput {
  create?: Maybe<
    ProductCreateWithoutInputsInput[] | ProductCreateWithoutInputsInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface InfluenceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  kind?: Maybe<FactorKind>;
  kind_not?: Maybe<FactorKind>;
  kind_in?: Maybe<FactorKind[] | FactorKind>;
  kind_not_in?: Maybe<FactorKind[] | FactorKind>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  dierction?: Maybe<Direction>;
  dierction_not?: Maybe<Direction>;
  dierction_in?: Maybe<Direction[] | Direction>;
  dierction_not_in?: Maybe<Direction[] | Direction>;
  AND?: Maybe<InfluenceScalarWhereInput[] | InfluenceScalarWhereInput>;
  OR?: Maybe<InfluenceScalarWhereInput[] | InfluenceScalarWhereInput>;
  NOT?: Maybe<InfluenceScalarWhereInput[] | InfluenceScalarWhereInput>;
}

export interface ProductCreateWithoutInputsInput {
  id?: Maybe<ID_Input>;
  name: String;
  outputs?: Maybe<CompanyCreateManyWithoutSellesInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface CompanyCreateManyWithoutSellesInput {
  create?: Maybe<
    CompanyCreateWithoutSellesInput[] | CompanyCreateWithoutSellesInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface InfluenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InfluenceWhereInput>;
  AND?: Maybe<
    InfluenceSubscriptionWhereInput[] | InfluenceSubscriptionWhereInput
  >;
  OR?: Maybe<
    InfluenceSubscriptionWhereInput[] | InfluenceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InfluenceSubscriptionWhereInput[] | InfluenceSubscriptionWhereInput
  >;
}

export interface CompanyCreateWithoutSellesInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  name: String;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  influences?: Maybe<InfluenceCreateManyWithoutCompanyInput>;
  purchases?: Maybe<ProductCreateManyWithoutInputsInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface ProductCreateManyWithoutOutputsInput {
  create?: Maybe<
    ProductCreateWithoutOutputsInput[] | ProductCreateWithoutOutputsInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductCreateWithoutOutputsInput {
  id?: Maybe<ID_Input>;
  name: String;
  inputs?: Maybe<CompanyCreateManyWithoutPurchasesInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  inputs_every?: Maybe<CompanyWhereInput>;
  inputs_some?: Maybe<CompanyWhereInput>;
  inputs_none?: Maybe<CompanyWhereInput>;
  outputs_every?: Maybe<CompanyWhereInput>;
  outputs_some?: Maybe<CompanyWhereInput>;
  outputs_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface CompanyCreateManyWithoutPurchasesInput {
  create?: Maybe<
    CompanyCreateWithoutPurchasesInput[] | CompanyCreateWithoutPurchasesInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  industry?: Maybe<String>;
  industry_not?: Maybe<String>;
  industry_in?: Maybe<String[] | String>;
  industry_not_in?: Maybe<String[] | String>;
  industry_lt?: Maybe<String>;
  industry_lte?: Maybe<String>;
  industry_gt?: Maybe<String>;
  industry_gte?: Maybe<String>;
  industry_contains?: Maybe<String>;
  industry_not_contains?: Maybe<String>;
  industry_starts_with?: Maybe<String>;
  industry_not_starts_with?: Maybe<String>;
  industry_ends_with?: Maybe<String>;
  industry_not_ends_with?: Maybe<String>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  enname?: Maybe<String>;
  enname_not?: Maybe<String>;
  enname_in?: Maybe<String[] | String>;
  enname_not_in?: Maybe<String[] | String>;
  enname_lt?: Maybe<String>;
  enname_lte?: Maybe<String>;
  enname_gt?: Maybe<String>;
  enname_gte?: Maybe<String>;
  enname_contains?: Maybe<String>;
  enname_not_contains?: Maybe<String>;
  enname_starts_with?: Maybe<String>;
  enname_not_starts_with?: Maybe<String>;
  enname_ends_with?: Maybe<String>;
  enname_not_ends_with?: Maybe<String>;
  market?: Maybe<String>;
  market_not?: Maybe<String>;
  market_in?: Maybe<String[] | String>;
  market_not_in?: Maybe<String[] | String>;
  market_lt?: Maybe<String>;
  market_lte?: Maybe<String>;
  market_gt?: Maybe<String>;
  market_gte?: Maybe<String>;
  market_contains?: Maybe<String>;
  market_not_contains?: Maybe<String>;
  market_starts_with?: Maybe<String>;
  market_not_starts_with?: Maybe<String>;
  market_ends_with?: Maybe<String>;
  market_not_ends_with?: Maybe<String>;
  exchange?: Maybe<String>;
  exchange_not?: Maybe<String>;
  exchange_in?: Maybe<String[] | String>;
  exchange_not_in?: Maybe<String[] | String>;
  exchange_lt?: Maybe<String>;
  exchange_lte?: Maybe<String>;
  exchange_gt?: Maybe<String>;
  exchange_gte?: Maybe<String>;
  exchange_contains?: Maybe<String>;
  exchange_not_contains?: Maybe<String>;
  exchange_starts_with?: Maybe<String>;
  exchange_not_starts_with?: Maybe<String>;
  exchange_ends_with?: Maybe<String>;
  exchange_not_ends_with?: Maybe<String>;
  currType?: Maybe<String>;
  currType_not?: Maybe<String>;
  currType_in?: Maybe<String[] | String>;
  currType_not_in?: Maybe<String[] | String>;
  currType_lt?: Maybe<String>;
  currType_lte?: Maybe<String>;
  currType_gt?: Maybe<String>;
  currType_gte?: Maybe<String>;
  currType_contains?: Maybe<String>;
  currType_not_contains?: Maybe<String>;
  currType_starts_with?: Maybe<String>;
  currType_not_starts_with?: Maybe<String>;
  currType_ends_with?: Maybe<String>;
  currType_not_ends_with?: Maybe<String>;
  listStatus?: Maybe<String>;
  listStatus_not?: Maybe<String>;
  listStatus_in?: Maybe<String[] | String>;
  listStatus_not_in?: Maybe<String[] | String>;
  listStatus_lt?: Maybe<String>;
  listStatus_lte?: Maybe<String>;
  listStatus_gt?: Maybe<String>;
  listStatus_gte?: Maybe<String>;
  listStatus_contains?: Maybe<String>;
  listStatus_not_contains?: Maybe<String>;
  listStatus_starts_with?: Maybe<String>;
  listStatus_not_starts_with?: Maybe<String>;
  listStatus_ends_with?: Maybe<String>;
  listStatus_not_ends_with?: Maybe<String>;
  listDate?: Maybe<String>;
  listDate_not?: Maybe<String>;
  listDate_in?: Maybe<String[] | String>;
  listDate_not_in?: Maybe<String[] | String>;
  listDate_lt?: Maybe<String>;
  listDate_lte?: Maybe<String>;
  listDate_gt?: Maybe<String>;
  listDate_gte?: Maybe<String>;
  listDate_contains?: Maybe<String>;
  listDate_not_contains?: Maybe<String>;
  listDate_starts_with?: Maybe<String>;
  listDate_not_starts_with?: Maybe<String>;
  listDate_ends_with?: Maybe<String>;
  listDate_not_ends_with?: Maybe<String>;
  delistDate?: Maybe<String>;
  delistDate_not?: Maybe<String>;
  delistDate_in?: Maybe<String[] | String>;
  delistDate_not_in?: Maybe<String[] | String>;
  delistDate_lt?: Maybe<String>;
  delistDate_lte?: Maybe<String>;
  delistDate_gt?: Maybe<String>;
  delistDate_gte?: Maybe<String>;
  delistDate_contains?: Maybe<String>;
  delistDate_not_contains?: Maybe<String>;
  delistDate_starts_with?: Maybe<String>;
  delistDate_not_starts_with?: Maybe<String>;
  delistDate_ends_with?: Maybe<String>;
  delistDate_not_ends_with?: Maybe<String>;
  isHS?: Maybe<String>;
  isHS_not?: Maybe<String>;
  isHS_in?: Maybe<String[] | String>;
  isHS_not_in?: Maybe<String[] | String>;
  isHS_lt?: Maybe<String>;
  isHS_lte?: Maybe<String>;
  isHS_gt?: Maybe<String>;
  isHS_gte?: Maybe<String>;
  isHS_contains?: Maybe<String>;
  isHS_not_contains?: Maybe<String>;
  isHS_starts_with?: Maybe<String>;
  isHS_not_starts_with?: Maybe<String>;
  isHS_ends_with?: Maybe<String>;
  isHS_not_ends_with?: Maybe<String>;
  scope?: Maybe<String>;
  scope_not?: Maybe<String>;
  scope_in?: Maybe<String[] | String>;
  scope_not_in?: Maybe<String[] | String>;
  scope_lt?: Maybe<String>;
  scope_lte?: Maybe<String>;
  scope_gt?: Maybe<String>;
  scope_gte?: Maybe<String>;
  scope_contains?: Maybe<String>;
  scope_not_contains?: Maybe<String>;
  scope_starts_with?: Maybe<String>;
  scope_not_starts_with?: Maybe<String>;
  scope_ends_with?: Maybe<String>;
  scope_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  influences_every?: Maybe<InfluenceWhereInput>;
  influences_some?: Maybe<InfluenceWhereInput>;
  influences_none?: Maybe<InfluenceWhereInput>;
  purchases_every?: Maybe<ProductWhereInput>;
  purchases_some?: Maybe<ProductWhereInput>;
  purchases_none?: Maybe<ProductWhereInput>;
  selles_every?: Maybe<ProductWhereInput>;
  selles_some?: Maybe<ProductWhereInput>;
  selles_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface CompanyCreateWithoutPurchasesInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  name: String;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  influences?: Maybe<InfluenceCreateManyWithoutCompanyInput>;
  selles?: Maybe<ProductCreateManyWithoutOutputsInput>;
}

export interface KeyWordWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<KeyWordWhereInput[] | KeyWordWhereInput>;
  OR?: Maybe<KeyWordWhereInput[] | KeyWordWhereInput>;
  NOT?: Maybe<KeyWordWhereInput[] | KeyWordWhereInput>;
}

export interface CompanyUpdateInput {
  symbol?: Maybe<String>;
  name?: Maybe<String>;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  influences?: Maybe<InfluenceUpdateManyWithoutCompanyInput>;
  purchases?: Maybe<ProductUpdateManyWithoutInputsInput>;
  selles?: Maybe<ProductUpdateManyWithoutOutputsInput>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  inputs?: Maybe<CompanyUpdateManyWithoutPurchasesInput>;
  outputs?: Maybe<CompanyUpdateManyWithoutSellesInput>;
}

export interface InfluenceUpdateManyWithoutCompanyInput {
  create?: Maybe<
    InfluenceCreateWithoutCompanyInput[] | InfluenceCreateWithoutCompanyInput
  >;
  delete?: Maybe<InfluenceWhereUniqueInput[] | InfluenceWhereUniqueInput>;
  connect?: Maybe<InfluenceWhereUniqueInput[] | InfluenceWhereUniqueInput>;
  set?: Maybe<InfluenceWhereUniqueInput[] | InfluenceWhereUniqueInput>;
  disconnect?: Maybe<InfluenceWhereUniqueInput[] | InfluenceWhereUniqueInput>;
  update?: Maybe<
    | InfluenceUpdateWithWhereUniqueWithoutCompanyInput[]
    | InfluenceUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | InfluenceUpsertWithWhereUniqueWithoutCompanyInput[]
    | InfluenceUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<InfluenceScalarWhereInput[] | InfluenceScalarWhereInput>;
  updateMany?: Maybe<
    | InfluenceUpdateManyWithWhereNestedInput[]
    | InfluenceUpdateManyWithWhereNestedInput
  >;
}

export type InfluenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InfluenceUpdateWithWhereUniqueWithoutCompanyInput {
  where: InfluenceWhereUniqueInput;
  data: InfluenceUpdateWithoutCompanyDataInput;
}

export interface KeyWordUpdateInput {
  name?: Maybe<String>;
}

export interface InfluenceUpdateWithoutCompanyDataInput {
  keywords?: Maybe<KeyWordUpdateManyInput>;
  kind?: Maybe<FactorKind>;
  name?: Maybe<String>;
  desc?: Maybe<String>;
  dierction?: Maybe<Direction>;
}

export type KeyWordWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface KeyWordUpdateManyInput {
  create?: Maybe<KeyWordCreateInput[] | KeyWordCreateInput>;
  update?: Maybe<
    | KeyWordUpdateWithWhereUniqueNestedInput[]
    | KeyWordUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | KeyWordUpsertWithWhereUniqueNestedInput[]
    | KeyWordUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<KeyWordWhereUniqueInput[] | KeyWordWhereUniqueInput>;
  connect?: Maybe<KeyWordWhereUniqueInput[] | KeyWordWhereUniqueInput>;
  set?: Maybe<KeyWordWhereUniqueInput[] | KeyWordWhereUniqueInput>;
  disconnect?: Maybe<KeyWordWhereUniqueInput[] | KeyWordWhereUniqueInput>;
  deleteMany?: Maybe<KeyWordScalarWhereInput[] | KeyWordScalarWhereInput>;
  updateMany?: Maybe<
    | KeyWordUpdateManyWithWhereNestedInput[]
    | KeyWordUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithoutInfluencesDataInput {
  symbol?: Maybe<String>;
  name?: Maybe<String>;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  purchases?: Maybe<ProductUpdateManyWithoutInputsInput>;
  selles?: Maybe<ProductUpdateManyWithoutOutputsInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutOutputsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutOutputsDataInput;
  create: ProductCreateWithoutOutputsInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface KeyWordUpdateDataInput {
  name?: Maybe<String>;
}

export interface CompanyCreateWithoutInfluencesInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  name: String;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  purchases?: Maybe<ProductCreateManyWithoutInputsInput>;
  selles?: Maybe<ProductCreateManyWithoutOutputsInput>;
}

export interface KeyWordUpsertWithWhereUniqueNestedInput {
  where: KeyWordWhereUniqueInput;
  update: KeyWordUpdateDataInput;
  create: KeyWordCreateInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface KeyWordScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<KeyWordScalarWhereInput[] | KeyWordScalarWhereInput>;
  OR?: Maybe<KeyWordScalarWhereInput[] | KeyWordScalarWhereInput>;
  NOT?: Maybe<KeyWordScalarWhereInput[] | KeyWordScalarWhereInput>;
}

export interface InfluenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  keywords_every?: Maybe<KeyWordWhereInput>;
  keywords_some?: Maybe<KeyWordWhereInput>;
  keywords_none?: Maybe<KeyWordWhereInput>;
  kind?: Maybe<FactorKind>;
  kind_not?: Maybe<FactorKind>;
  kind_in?: Maybe<FactorKind[] | FactorKind>;
  kind_not_in?: Maybe<FactorKind[] | FactorKind>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  dierction?: Maybe<Direction>;
  dierction_not?: Maybe<Direction>;
  dierction_in?: Maybe<Direction[] | Direction>;
  dierction_not_in?: Maybe<Direction[] | Direction>;
  AND?: Maybe<InfluenceWhereInput[] | InfluenceWhereInput>;
  OR?: Maybe<InfluenceWhereInput[] | InfluenceWhereInput>;
  NOT?: Maybe<InfluenceWhereInput[] | InfluenceWhereInput>;
}

export interface KeyWordUpdateManyWithWhereNestedInput {
  where: KeyWordScalarWhereInput;
  data: KeyWordUpdateManyDataInput;
}

export interface EventUpdateManyMutationInput {
  title?: Maybe<String>;
  src?: Maybe<String>;
  srcKind?: Maybe<SrcKind>;
  reportTime?: Maybe<DateTimeInput>;
  happen?: Maybe<TimeKind>;
  happenTime?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
}

export interface KeyWordUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  src: String;
  srcKind: SrcKind;
  reportTime: DateTimeInput;
  happen: TimeKind;
  happenTime: DateTimeInput;
  content: String;
  keyWords?: Maybe<KeyWordCreateManyInput>;
}

export interface InfluenceUpsertWithWhereUniqueWithoutCompanyInput {
  where: InfluenceWhereUniqueInput;
  update: InfluenceUpdateWithoutCompanyDataInput;
  create: InfluenceCreateWithoutCompanyInput;
}

export interface InfluenceCreateManyWithoutCompanyInput {
  create?: Maybe<
    InfluenceCreateWithoutCompanyInput[] | InfluenceCreateWithoutCompanyInput
  >;
  connect?: Maybe<InfluenceWhereUniqueInput[] | InfluenceWhereUniqueInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutPurchasesInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutPurchasesDataInput;
  create: CompanyCreateWithoutPurchasesInput;
}

export interface KeyWordCreateManyInput {
  create?: Maybe<KeyWordCreateInput[] | KeyWordCreateInput>;
  connect?: Maybe<KeyWordWhereUniqueInput[] | KeyWordWhereUniqueInput>;
}

export interface InfluenceUpdateManyWithWhereNestedInput {
  where: InfluenceScalarWhereInput;
  data: InfluenceUpdateManyDataInput;
}

export interface KeyWordSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<KeyWordWhereInput>;
  AND?: Maybe<KeyWordSubscriptionWhereInput[] | KeyWordSubscriptionWhereInput>;
  OR?: Maybe<KeyWordSubscriptionWhereInput[] | KeyWordSubscriptionWhereInput>;
  NOT?: Maybe<KeyWordSubscriptionWhereInput[] | KeyWordSubscriptionWhereInput>;
}

export interface InfluenceUpdateManyDataInput {
  kind?: Maybe<FactorKind>;
  name?: Maybe<String>;
  desc?: Maybe<String>;
  dierction?: Maybe<Direction>;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
}

export interface ProductUpdateManyWithoutInputsInput {
  create?: Maybe<
    ProductCreateWithoutInputsInput[] | ProductCreateWithoutInputsInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutInputsInput[]
    | ProductUpdateWithWhereUniqueWithoutInputsInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutInputsInput[]
    | ProductUpsertWithWhereUniqueWithoutInputsInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  password: String;
  role?: Maybe<Role>;
}

export interface ProductUpdateWithWhereUniqueWithoutInputsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutInputsDataInput;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ProductUpdateWithoutInputsDataInput {
  name?: Maybe<String>;
  outputs?: Maybe<CompanyUpdateManyWithoutSellesInput>;
}

export interface KeyWordUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CompanyUpdateManyWithoutSellesInput {
  create?: Maybe<
    CompanyCreateWithoutSellesInput[] | CompanyCreateWithoutSellesInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutSellesInput[]
    | CompanyUpdateWithWhereUniqueWithoutSellesInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutSellesInput[]
    | CompanyUpsertWithWhereUniqueWithoutSellesInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpsertWithoutInfluencesInput {
  update: CompanyUpdateWithoutInfluencesDataInput;
  create: CompanyCreateWithoutInfluencesInput;
}

export interface CompanyUpdateWithWhereUniqueWithoutSellesInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutSellesDataInput;
}

export interface InfluenceUpdateInput {
  keywords?: Maybe<KeyWordUpdateManyInput>;
  kind?: Maybe<FactorKind>;
  name?: Maybe<String>;
  desc?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutInfluencesInput>;
  dierction?: Maybe<Direction>;
}

export interface CompanyUpdateWithoutSellesDataInput {
  symbol?: Maybe<String>;
  name?: Maybe<String>;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  influences?: Maybe<InfluenceUpdateManyWithoutCompanyInput>;
  purchases?: Maybe<ProductUpdateManyWithoutInputsInput>;
}

export interface InfluenceCreateInput {
  id?: Maybe<ID_Input>;
  keywords?: Maybe<KeyWordCreateManyInput>;
  kind: FactorKind;
  name: String;
  desc: String;
  company: CompanyCreateOneWithoutInfluencesInput;
  dierction: Direction;
}

export interface CompanyUpsertWithWhereUniqueWithoutSellesInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutSellesDataInput;
  create: CompanyCreateWithoutSellesInput;
}

export interface EventUpdateInput {
  title?: Maybe<String>;
  src?: Maybe<String>;
  srcKind?: Maybe<SrcKind>;
  reportTime?: Maybe<DateTimeInput>;
  happen?: Maybe<TimeKind>;
  happenTime?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  keyWords?: Maybe<KeyWordUpdateManyInput>;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  industry?: Maybe<String>;
  industry_not?: Maybe<String>;
  industry_in?: Maybe<String[] | String>;
  industry_not_in?: Maybe<String[] | String>;
  industry_lt?: Maybe<String>;
  industry_lte?: Maybe<String>;
  industry_gt?: Maybe<String>;
  industry_gte?: Maybe<String>;
  industry_contains?: Maybe<String>;
  industry_not_contains?: Maybe<String>;
  industry_starts_with?: Maybe<String>;
  industry_not_starts_with?: Maybe<String>;
  industry_ends_with?: Maybe<String>;
  industry_not_ends_with?: Maybe<String>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  enname?: Maybe<String>;
  enname_not?: Maybe<String>;
  enname_in?: Maybe<String[] | String>;
  enname_not_in?: Maybe<String[] | String>;
  enname_lt?: Maybe<String>;
  enname_lte?: Maybe<String>;
  enname_gt?: Maybe<String>;
  enname_gte?: Maybe<String>;
  enname_contains?: Maybe<String>;
  enname_not_contains?: Maybe<String>;
  enname_starts_with?: Maybe<String>;
  enname_not_starts_with?: Maybe<String>;
  enname_ends_with?: Maybe<String>;
  enname_not_ends_with?: Maybe<String>;
  market?: Maybe<String>;
  market_not?: Maybe<String>;
  market_in?: Maybe<String[] | String>;
  market_not_in?: Maybe<String[] | String>;
  market_lt?: Maybe<String>;
  market_lte?: Maybe<String>;
  market_gt?: Maybe<String>;
  market_gte?: Maybe<String>;
  market_contains?: Maybe<String>;
  market_not_contains?: Maybe<String>;
  market_starts_with?: Maybe<String>;
  market_not_starts_with?: Maybe<String>;
  market_ends_with?: Maybe<String>;
  market_not_ends_with?: Maybe<String>;
  exchange?: Maybe<String>;
  exchange_not?: Maybe<String>;
  exchange_in?: Maybe<String[] | String>;
  exchange_not_in?: Maybe<String[] | String>;
  exchange_lt?: Maybe<String>;
  exchange_lte?: Maybe<String>;
  exchange_gt?: Maybe<String>;
  exchange_gte?: Maybe<String>;
  exchange_contains?: Maybe<String>;
  exchange_not_contains?: Maybe<String>;
  exchange_starts_with?: Maybe<String>;
  exchange_not_starts_with?: Maybe<String>;
  exchange_ends_with?: Maybe<String>;
  exchange_not_ends_with?: Maybe<String>;
  currType?: Maybe<String>;
  currType_not?: Maybe<String>;
  currType_in?: Maybe<String[] | String>;
  currType_not_in?: Maybe<String[] | String>;
  currType_lt?: Maybe<String>;
  currType_lte?: Maybe<String>;
  currType_gt?: Maybe<String>;
  currType_gte?: Maybe<String>;
  currType_contains?: Maybe<String>;
  currType_not_contains?: Maybe<String>;
  currType_starts_with?: Maybe<String>;
  currType_not_starts_with?: Maybe<String>;
  currType_ends_with?: Maybe<String>;
  currType_not_ends_with?: Maybe<String>;
  listStatus?: Maybe<String>;
  listStatus_not?: Maybe<String>;
  listStatus_in?: Maybe<String[] | String>;
  listStatus_not_in?: Maybe<String[] | String>;
  listStatus_lt?: Maybe<String>;
  listStatus_lte?: Maybe<String>;
  listStatus_gt?: Maybe<String>;
  listStatus_gte?: Maybe<String>;
  listStatus_contains?: Maybe<String>;
  listStatus_not_contains?: Maybe<String>;
  listStatus_starts_with?: Maybe<String>;
  listStatus_not_starts_with?: Maybe<String>;
  listStatus_ends_with?: Maybe<String>;
  listStatus_not_ends_with?: Maybe<String>;
  listDate?: Maybe<String>;
  listDate_not?: Maybe<String>;
  listDate_in?: Maybe<String[] | String>;
  listDate_not_in?: Maybe<String[] | String>;
  listDate_lt?: Maybe<String>;
  listDate_lte?: Maybe<String>;
  listDate_gt?: Maybe<String>;
  listDate_gte?: Maybe<String>;
  listDate_contains?: Maybe<String>;
  listDate_not_contains?: Maybe<String>;
  listDate_starts_with?: Maybe<String>;
  listDate_not_starts_with?: Maybe<String>;
  listDate_ends_with?: Maybe<String>;
  listDate_not_ends_with?: Maybe<String>;
  delistDate?: Maybe<String>;
  delistDate_not?: Maybe<String>;
  delistDate_in?: Maybe<String[] | String>;
  delistDate_not_in?: Maybe<String[] | String>;
  delistDate_lt?: Maybe<String>;
  delistDate_lte?: Maybe<String>;
  delistDate_gt?: Maybe<String>;
  delistDate_gte?: Maybe<String>;
  delistDate_contains?: Maybe<String>;
  delistDate_not_contains?: Maybe<String>;
  delistDate_starts_with?: Maybe<String>;
  delistDate_not_starts_with?: Maybe<String>;
  delistDate_ends_with?: Maybe<String>;
  delistDate_not_ends_with?: Maybe<String>;
  isHS?: Maybe<String>;
  isHS_not?: Maybe<String>;
  isHS_in?: Maybe<String[] | String>;
  isHS_not_in?: Maybe<String[] | String>;
  isHS_lt?: Maybe<String>;
  isHS_lte?: Maybe<String>;
  isHS_gt?: Maybe<String>;
  isHS_gte?: Maybe<String>;
  isHS_contains?: Maybe<String>;
  isHS_not_contains?: Maybe<String>;
  isHS_starts_with?: Maybe<String>;
  isHS_not_starts_with?: Maybe<String>;
  isHS_ends_with?: Maybe<String>;
  isHS_not_ends_with?: Maybe<String>;
  scope?: Maybe<String>;
  scope_not?: Maybe<String>;
  scope_in?: Maybe<String[] | String>;
  scope_not_in?: Maybe<String[] | String>;
  scope_lt?: Maybe<String>;
  scope_lte?: Maybe<String>;
  scope_gt?: Maybe<String>;
  scope_gte?: Maybe<String>;
  scope_contains?: Maybe<String>;
  scope_not_contains?: Maybe<String>;
  scope_starts_with?: Maybe<String>;
  scope_not_starts_with?: Maybe<String>;
  scope_ends_with?: Maybe<String>;
  scope_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  name: String;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
  influences?: Maybe<InfluenceCreateManyWithoutCompanyInput>;
  purchases?: Maybe<ProductCreateManyWithoutInputsInput>;
  selles?: Maybe<ProductCreateManyWithoutOutputsInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface CompanyUpdateManyDataInput {
  symbol?: Maybe<String>;
  name?: Maybe<String>;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
}

export interface ProductUpsertWithWhereUniqueWithoutInputsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutInputsDataInput;
  create: ProductCreateWithoutInputsInput;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  inputs?: Maybe<CompanyCreateManyWithoutPurchasesInput>;
  outputs?: Maybe<CompanyCreateManyWithoutSellesInput>;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface CompanyUpdateOneRequiredWithoutInfluencesInput {
  create?: Maybe<CompanyCreateWithoutInfluencesInput>;
  update?: Maybe<CompanyUpdateWithoutInfluencesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutInfluencesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ProductUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface InfluenceCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  keywords?: Maybe<KeyWordCreateManyInput>;
  kind: FactorKind;
  name: String;
  desc: String;
  dierction: Direction;
}

export interface ProductUpdateManyWithoutOutputsInput {
  create?: Maybe<
    ProductCreateWithoutOutputsInput[] | ProductCreateWithoutOutputsInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutOutputsInput[]
    | ProductUpdateWithWhereUniqueWithoutOutputsInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutOutputsInput[]
    | ProductUpsertWithWhereUniqueWithoutOutputsInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  srcKind?: Maybe<SrcKind>;
  srcKind_not?: Maybe<SrcKind>;
  srcKind_in?: Maybe<SrcKind[] | SrcKind>;
  srcKind_not_in?: Maybe<SrcKind[] | SrcKind>;
  reportTime?: Maybe<DateTimeInput>;
  reportTime_not?: Maybe<DateTimeInput>;
  reportTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportTime_lt?: Maybe<DateTimeInput>;
  reportTime_lte?: Maybe<DateTimeInput>;
  reportTime_gt?: Maybe<DateTimeInput>;
  reportTime_gte?: Maybe<DateTimeInput>;
  happen?: Maybe<TimeKind>;
  happen_not?: Maybe<TimeKind>;
  happen_in?: Maybe<TimeKind[] | TimeKind>;
  happen_not_in?: Maybe<TimeKind[] | TimeKind>;
  happenTime?: Maybe<DateTimeInput>;
  happenTime_not?: Maybe<DateTimeInput>;
  happenTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  happenTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  happenTime_lt?: Maybe<DateTimeInput>;
  happenTime_lte?: Maybe<DateTimeInput>;
  happenTime_gt?: Maybe<DateTimeInput>;
  happenTime_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  keyWords_every?: Maybe<KeyWordWhereInput>;
  keyWords_some?: Maybe<KeyWordWhereInput>;
  keyWords_none?: Maybe<KeyWordWhereInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface CompanyUpdateWithWhereUniqueWithoutPurchasesInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutPurchasesDataInput;
}

export interface CompanyUpdateManyWithoutPurchasesInput {
  create?: Maybe<
    CompanyCreateWithoutPurchasesInput[] | CompanyCreateWithoutPurchasesInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutPurchasesInput[]
    | CompanyUpdateWithWhereUniqueWithoutPurchasesInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutPurchasesInput[]
    | CompanyUpsertWithWhereUniqueWithoutPurchasesInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithoutOutputsDataInput {
  name?: Maybe<String>;
  inputs?: Maybe<CompanyUpdateManyWithoutPurchasesInput>;
}

export interface ProductUpdateWithWhereUniqueWithoutOutputsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutOutputsDataInput;
}

export interface InfluenceUpdateManyMutationInput {
  kind?: Maybe<FactorKind>;
  name?: Maybe<String>;
  desc?: Maybe<String>;
  dierction?: Maybe<Direction>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface CompanyUpdateManyMutationInput {
  symbol?: Maybe<String>;
  name?: Maybe<String>;
  area?: Maybe<String>;
  industry?: Maybe<String>;
  fullname?: Maybe<String>;
  enname?: Maybe<String>;
  market?: Maybe<String>;
  exchange?: Maybe<String>;
  currType?: Maybe<String>;
  listStatus?: Maybe<String>;
  listDate?: Maybe<String>;
  delistDate?: Maybe<String>;
  isHS?: Maybe<String>;
  scope?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface CompanyCreateOneWithoutInfluencesInput {
  create?: Maybe<CompanyCreateWithoutInfluencesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  password: String;
  role: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface KeyWord {
  id: ID_Output;
  name: String;
}

export interface KeyWordPromise extends Promise<KeyWord>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface KeyWordSubscription
  extends Promise<AsyncIterator<KeyWord>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface KeyWordNullablePromise
  extends Promise<KeyWord | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface Influence {
  id: ID_Output;
  kind: FactorKind;
  name: String;
  desc: String;
  dierction: Direction;
}

export interface InfluencePromise extends Promise<Influence>, Fragmentable {
  id: () => Promise<ID_Output>;
  keywords: <T = FragmentableArray<KeyWord>>(args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  kind: () => Promise<FactorKind>;
  name: () => Promise<String>;
  desc: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  dierction: () => Promise<Direction>;
}

export interface InfluenceSubscription
  extends Promise<AsyncIterator<Influence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  keywords: <T = Promise<AsyncIterator<KeyWordSubscription>>>(args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  kind: () => Promise<AsyncIterator<FactorKind>>;
  name: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  dierction: () => Promise<AsyncIterator<Direction>>;
}

export interface InfluenceNullablePromise
  extends Promise<Influence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  keywords: <T = FragmentableArray<KeyWord>>(args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  kind: () => Promise<FactorKind>;
  name: () => Promise<String>;
  desc: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  dierction: () => Promise<Direction>;
}

export interface Event {
  id: ID_Output;
  title: String;
  src: String;
  srcKind: SrcKind;
  reportTime: DateTimeOutput;
  happen: TimeKind;
  happenTime: DateTimeOutput;
  content: String;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  src: () => Promise<String>;
  srcKind: () => Promise<SrcKind>;
  reportTime: () => Promise<DateTimeOutput>;
  happen: () => Promise<TimeKind>;
  happenTime: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  keyWords: <T = FragmentableArray<KeyWord>>(args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
  srcKind: () => Promise<AsyncIterator<SrcKind>>;
  reportTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  happen: () => Promise<AsyncIterator<TimeKind>>;
  happenTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  keyWords: <T = Promise<AsyncIterator<KeyWordSubscription>>>(args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  src: () => Promise<String>;
  srcKind: () => Promise<SrcKind>;
  reportTime: () => Promise<DateTimeOutput>;
  happen: () => Promise<TimeKind>;
  happenTime: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  keyWords: <T = FragmentableArray<KeyWord>>(args?: {
    where?: KeyWordWhereInput;
    orderBy?: KeyWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Company {
  id: ID_Output;
  symbol: String;
  name: String;
  area?: String;
  industry?: String;
  fullname?: String;
  enname?: String;
  market?: String;
  exchange?: String;
  currType?: String;
  listStatus?: String;
  listDate?: String;
  delistDate?: String;
  isHS?: String;
  scope?: String;
  desc?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  industry: () => Promise<String>;
  fullname: () => Promise<String>;
  enname: () => Promise<String>;
  market: () => Promise<String>;
  exchange: () => Promise<String>;
  currType: () => Promise<String>;
  listStatus: () => Promise<String>;
  listDate: () => Promise<String>;
  delistDate: () => Promise<String>;
  isHS: () => Promise<String>;
  scope: () => Promise<String>;
  desc: () => Promise<String>;
  influences: <T = FragmentableArray<Influence>>(args?: {
    where?: InfluenceWhereInput;
    orderBy?: InfluenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  purchases: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  selles: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  industry: () => Promise<AsyncIterator<String>>;
  fullname: () => Promise<AsyncIterator<String>>;
  enname: () => Promise<AsyncIterator<String>>;
  market: () => Promise<AsyncIterator<String>>;
  exchange: () => Promise<AsyncIterator<String>>;
  currType: () => Promise<AsyncIterator<String>>;
  listStatus: () => Promise<AsyncIterator<String>>;
  listDate: () => Promise<AsyncIterator<String>>;
  delistDate: () => Promise<AsyncIterator<String>>;
  isHS: () => Promise<AsyncIterator<String>>;
  scope: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  influences: <T = Promise<AsyncIterator<InfluenceSubscription>>>(args?: {
    where?: InfluenceWhereInput;
    orderBy?: InfluenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  purchases: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  selles: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  industry: () => Promise<String>;
  fullname: () => Promise<String>;
  enname: () => Promise<String>;
  market: () => Promise<String>;
  exchange: () => Promise<String>;
  currType: () => Promise<String>;
  listStatus: () => Promise<String>;
  listDate: () => Promise<String>;
  delistDate: () => Promise<String>;
  isHS: () => Promise<String>;
  scope: () => Promise<String>;
  desc: () => Promise<String>;
  influences: <T = FragmentableArray<Influence>>(args?: {
    where?: InfluenceWhereInput;
    orderBy?: InfluenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  purchases: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  selles: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inputs: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  outputs: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  inputs: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  outputs: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inputs: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  outputs: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface KeyWordEdge {
  node: KeyWord;
  cursor: String;
}

export interface KeyWordEdgePromise extends Promise<KeyWordEdge>, Fragmentable {
  node: <T = KeyWordPromise>() => T;
  cursor: () => Promise<String>;
}

export interface KeyWordEdgeSubscription
  extends Promise<AsyncIterator<KeyWordEdge>>,
    Fragmentable {
  node: <T = KeyWordSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  symbol: String;
  name: String;
  area?: String;
  industry?: String;
  fullname?: String;
  enname?: String;
  market?: String;
  exchange?: String;
  currType?: String;
  listStatus?: String;
  listDate?: String;
  delistDate?: String;
  isHS?: String;
  scope?: String;
  desc?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  industry: () => Promise<String>;
  fullname: () => Promise<String>;
  enname: () => Promise<String>;
  market: () => Promise<String>;
  exchange: () => Promise<String>;
  currType: () => Promise<String>;
  listStatus: () => Promise<String>;
  listDate: () => Promise<String>;
  delistDate: () => Promise<String>;
  isHS: () => Promise<String>;
  scope: () => Promise<String>;
  desc: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  industry: () => Promise<AsyncIterator<String>>;
  fullname: () => Promise<AsyncIterator<String>>;
  enname: () => Promise<AsyncIterator<String>>;
  market: () => Promise<AsyncIterator<String>>;
  exchange: () => Promise<AsyncIterator<String>>;
  currType: () => Promise<AsyncIterator<String>>;
  listStatus: () => Promise<AsyncIterator<String>>;
  listDate: () => Promise<AsyncIterator<String>>;
  delistDate: () => Promise<AsyncIterator<String>>;
  isHS: () => Promise<AsyncIterator<String>>;
  scope: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInfluence {
  count: Int;
}

export interface AggregateInfluencePromise
  extends Promise<AggregateInfluence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInfluenceSubscription
  extends Promise<AsyncIterator<AggregateInfluence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface InfluenceConnection {
  pageInfo: PageInfo;
  edges: InfluenceEdge[];
}

export interface InfluenceConnectionPromise
  extends Promise<InfluenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InfluenceEdge>>() => T;
  aggregate: <T = AggregateInfluencePromise>() => T;
}

export interface InfluenceConnectionSubscription
  extends Promise<AsyncIterator<InfluenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InfluenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInfluenceSubscription>() => T;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventPreviousValues {
  id: ID_Output;
  title: String;
  src: String;
  srcKind: SrcKind;
  reportTime: DateTimeOutput;
  happen: TimeKind;
  happenTime: DateTimeOutput;
  content: String;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  src: () => Promise<String>;
  srcKind: () => Promise<SrcKind>;
  reportTime: () => Promise<DateTimeOutput>;
  happen: () => Promise<TimeKind>;
  happenTime: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
  srcKind: () => Promise<AsyncIterator<SrcKind>>;
  reportTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  happen: () => Promise<AsyncIterator<TimeKind>>;
  happenTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InfluenceSubscriptionPayload {
  mutation: MutationType;
  node: Influence;
  updatedFields: String[];
  previousValues: InfluencePreviousValues;
}

export interface InfluenceSubscriptionPayloadPromise
  extends Promise<InfluenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InfluencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InfluencePreviousValuesPromise>() => T;
}

export interface InfluenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InfluenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InfluenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InfluencePreviousValuesSubscription>() => T;
}

export interface KeyWordConnection {
  pageInfo: PageInfo;
  edges: KeyWordEdge[];
}

export interface KeyWordConnectionPromise
  extends Promise<KeyWordConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<KeyWordEdge>>() => T;
  aggregate: <T = AggregateKeyWordPromise>() => T;
}

export interface KeyWordConnectionSubscription
  extends Promise<AsyncIterator<KeyWordConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<KeyWordEdgeSubscription>>>() => T;
  aggregate: <T = AggregateKeyWordSubscription>() => T;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface KeyWordPreviousValues {
  id: ID_Output;
  name: String;
}

export interface KeyWordPreviousValuesPromise
  extends Promise<KeyWordPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface KeyWordPreviousValuesSubscription
  extends Promise<AsyncIterator<KeyWordPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface KeyWordSubscriptionPayload {
  mutation: MutationType;
  node: KeyWord;
  updatedFields: String[];
  previousValues: KeyWordPreviousValues;
}

export interface KeyWordSubscriptionPayloadPromise
  extends Promise<KeyWordSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = KeyWordPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = KeyWordPreviousValuesPromise>() => T;
}

export interface KeyWordSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyWordSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = KeyWordSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = KeyWordPreviousValuesSubscription>() => T;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface InfluencePreviousValues {
  id: ID_Output;
  kind: FactorKind;
  name: String;
  desc: String;
  dierction: Direction;
}

export interface InfluencePreviousValuesPromise
  extends Promise<InfluencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<FactorKind>;
  name: () => Promise<String>;
  desc: () => Promise<String>;
  dierction: () => Promise<Direction>;
}

export interface InfluencePreviousValuesSubscription
  extends Promise<AsyncIterator<InfluencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<FactorKind>>;
  name: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  dierction: () => Promise<AsyncIterator<Direction>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface InfluenceEdge {
  node: Influence;
  cursor: String;
}

export interface InfluenceEdgePromise
  extends Promise<InfluenceEdge>,
    Fragmentable {
  node: <T = InfluencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InfluenceEdgeSubscription
  extends Promise<AsyncIterator<InfluenceEdge>>,
    Fragmentable {
  node: <T = InfluenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateKeyWord {
  count: Int;
}

export interface AggregateKeyWordPromise
  extends Promise<AggregateKeyWord>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKeyWordSubscription
  extends Promise<AsyncIterator<AggregateKeyWord>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  username: String;
  password: String;
  role: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "TimeKind",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "SrcKind",
    embedded: false
  },
  {
    name: "KeyWord",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Direction",
    embedded: false
  },
  {
    name: "FactorKind",
    embedded: false
  },
  {
    name: "Influence",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
